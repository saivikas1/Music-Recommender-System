# -*- coding: utf-8 -*-
"""
Recommender_Systems_spotify.ipynb
Automatically generated by Colaboratory.
"""

import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
from spotipy.oauth2 import SpotifyOAuth
import spotipy.util as util
from skimage import io
import matplotlib.pyplot as plt
import pandas as pd
from datetime import datetime
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity

# loading spotify data
spotify_data = pd.read_csv('SpotifyFeatures.csv')
spotify_data.head()

# data cleaning
df_features = spotify_data
genre_OHE = pd.get_dummies(df_features.genre)
key_OHE = pd.get_dummies(df_features.key)

# feature scaling
scaled_features = MinMaxScaler().fit_transform([
  df_features['acousticness'].values,
  df_features['danceability'].values,
  df_features['duration_ms'].values,
  df_features['energy'].values,
  df_features['instrumentalness'].values,
  df_features['liveness'].values,
  df_features['loudness'].values,
  df_features['speechiness'].values,
  df_features['tempo'].values,
  df_features['valence'].values,
  ])
df_features[['acousticness','danceability','duration_ms','energy','instrumentalness','liveness','loudness','speechiness','tempo','valence']] = scaled_features.T

# elimination the highly correlated features and categorical features
df_features = df_features.drop('genre',axis = 1)
df_features = df_features.drop('artist_name', axis = 1)
df_features = df_features.drop('track_name', axis = 1)
df_features = df_features.drop('popularity',axis = 1)
df_features = df_features.drop('key', axis = 1)
df_features = df_features.drop('mode', axis = 1)
df_features = df_features.drop('time_signature', axis = 1)
df_features = df_features.join(genre_OHE)
df_features = df_features.join(key_OHE)

# A client_id is selected at random and can be changed as per preference to get recommondations
# connecting to spotify web-API
client_id = '773abbb9c7d24160930dbb2263c541d3'
client_secret= '3bd455e6f4b74576baafcae3471d0796'

# getting the df_playlist
#scope = 'user-library-read'
scope = 'playlist-read-private'
token = util.prompt_for_user_token(
    scope,
    client_id= client_id,
    client_secret=client_secret,
    redirect_uri='http://localhost:8888/callback'
  )
# Feature Engineering
sp = spotipy.Spotify(auth=token)
playlist_dictionary = {}
playlist_cover_artist = {}

for i in sp.current_user_playlists()['items']:
    playlist_dictionary[i['name']] = i['uri'].split(':')[2]
    playlist_cover_artist[i['uri'].split(':')[2]] = i['images'][0]['url']

print(playlist_dictionary)

# creating playlist dataframe with extended features using spotify data
def df_generate_playlist(playlist_name, playlist_dictionary, spotify_data):
    df_playlist = pd.DataFrame()
    for i, j in enumerate(sp.playlist(playlist_dictionary[playlist_name])['tracks']['items']):
        df_playlist.loc[i, 'artist'] = j['track']['artists'][0]['name']
        df_playlist.loc[i, 'track_name'] = j['track']['name']
        df_playlist.loc[i, 'track_id'] = j['track']['id']

        # Check if 'images' list exists and has elements
        album_images = j['track']['album'].get('images', [])
        if album_images:
            # Use the first image (index 0) if available
            df_playlist.loc[i, 'url'] = album_images[0]['url']
        else:
            # Set a default URL or take appropriate action
            df_playlist.loc[i, 'url'] = 'default_url'

        df_playlist.loc[i, 'date_added'] = j['added_at']

    df_playlist['date_added'] = pd.to_datetime(df_playlist['date_added'])
    df_playlist = df_playlist[df_playlist['track_id'].isin(spotify_data['track_id'].values)].sort_values('date_added', ascending=False)
    return df_playlist


playlist_df = df_generate_playlist('Fav', playlist_dictionary, spotify_data)
playlist_df.head()

from skimage import io
import matplotlib.pyplot as plt

# visualising the cover art of the song using matplotlib
import math

def cover_artist_visualize(playlist_df):
    temp = playlist_df['url'].values
    plt.figure(figsize=(15, int(0.625 * len(temp))), facecolor='#8cfc03')
    columns = 5

    # Calculate the number of rows rounded up to the nearest integer
    rows = math.ceil(len(temp) / columns)

    for i, url in enumerate(temp):
        plt.subplot(rows, columns, i + 1)
        image = io.imread(url)
        plt.imshow(image)
        plt.xticks([])
        plt.yticks([])
        s = '' 
        plt.xlabel(s.join(playlist_df['track_name'].values[i].split(' ')[:4]), fontsize=10, fontweight='bold')
        plt.tight_layout(h_pad=0.8, w_pad=0)
        plt.subplots_adjust(wspace=None, hspace=None)

    plt.show()

cover_artist_visualize(playlist_df)

cover_artist_visualize(playlist_df)

# creating playlist vector
def create_playlist_vector(spotify_features, playlist_df, weight_factor):
    
    spotifyFeaturesPlaylist = spotify_features[spotify_features['track_id'].isin(playlist_df['track_id'].values)]
    spotifyFeaturesPlaylist = spotifyFeaturesPlaylist.merge(playlist_df[['track_id','date_added']], on = 'track_id', how = 'inner')
    spotifyFeaturesNonplaylist = spotify_features[~spotify_features['track_id'].isin(playlist_df['track_id'].values)]
    playlistFeatureSet = spotifyFeaturesPlaylist.sort_values('date_added',ascending=False)
    most_RecentDate = playlistFeatureSet.iloc[0,-1]
    for ix, row in playlistFeatureSet.iterrows():
        playlistFeatureSet.loc[ix,'days_from_recent'] = int((most_RecentDate.to_pydatetime() - row.iloc[-1].to_pydatetime()).days)
    playlistFeatureSet['weight'] = playlistFeatureSet['days_from_recent'].apply(lambda x: weight_factor ** (-x))
    playlistFeatureSetWeighted = playlistFeatureSet.copy()
    playlistFeatureSetWeighted.update(playlistFeatureSetWeighted.iloc[:,:-3].mul(playlistFeatureSetWeighted.weight.astype(int),0))   
    playlistFeatureSetWeightedFinal = playlistFeatureSetWeighted.iloc[:, :-3]
    return playlistFeatureSetWeightedFinal.sum(axis = 0), spotifyFeaturesNonplaylist

playlist_vector, nonplaylist_df = create_playlist_vector(df_features, playlist_df, 1.2)
print(playlist_vector.shape)
print(nonplaylist_df.head())

# Generating Recommondations
def generate_recommendation(spotify_data, playlist_vector, nonplaylist_df):

    nonPlaylist = spotify_data[spotify_data['track_id'].isin(nonplaylist_df['track_id'].values)]
    nonPlaylist['sim'] = cosine_similarity(nonplaylist_df.drop(['track_id'], axis = 1).values, playlist_vector.drop(labels = 'track_id').values.reshape(1, -1))[:,0]
    nonPlaylistTop15 = nonPlaylist.sort_values('sim',ascending = False).head(15)
    nonPlaylistTop15['url'] = nonPlaylistTop15['track_id'].apply(lambda x: sp.track(x)['album']['images'][1]['url'])
    return  nonPlaylistTop15

# Giving the top 15 song suggestions for the given client id
top15 = generate_recommendation(spotify_data, playlist_vector, nonplaylist_df)  
top15.head()

cover_artist_visualize(top15)